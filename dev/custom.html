<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Customize · Julia MRI Package</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Julia MRI Package logo"/></a><h1>Julia MRI Package</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="gettingStarted.html">Getting Started</a></li><li><a class="toctext" href="overview.html">Overview</a></li><li><a class="toctext" href="acquisitionData.html">Acquisition Data</a></li><li><a class="toctext" href="filehandling.html">File Handling</a></li><li><a class="toctext" href="image.html">Images</a></li><li><a class="toctext" href="trajectories.html">Trajectory</a></li><li><a class="toctext" href="operators.html">Imaging Operators</a></li><li><a class="toctext" href="offresonance.html">Offresonance</a></li><li><a class="toctext" href="SENSE.html">Parallel Imaging</a></li><li><a class="toctext" href="compressedSensing.html">Compressed Sensing</a></li><li class="current"><a class="toctext" href="custom.html">Customize</a><ul class="internal"></ul></li><li><a class="toctext" href="API.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="custom.html">Customize</a></li></ul><a class="edit-page" href="https://github.com/MagneticResonanceImaging/MRIReco.jl/blob/master/docs/src/custom.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Customize</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Customization-1" href="#Customization-1">Customization</a></h1><p>We promised that MRIReco allows for customization. Lets in the following consider a custom data-driven sparsifying transform that is currently not part of MRIReco.jl [S. Ravishankar and Y. Bresler, IEEE Trans. Med. Imaging, 30 (5), 2011].</p><p>It is based on</p><ul><li>Learn a dictionary from a reference image (e.g. adjacent slice) using KSVD  <span>$\color{green}\checkmark$</span></li><li>Implement sparsifying transform which analyses the input image in terms of the dictionary</li></ul><p><img src="assets/dictTrafo.png" alt="DictTrafo"/></p><p>In order to implement this, we first need the analyze function where we can reuse the <code>matchingpursuit</code> function from Wavelets.jl</p><pre><code class="language-julia">function analyzeImage(x::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},
                      psize::NTuple{2,Int64};t0::Int64=size(D,2),tol=1e-3) where T
  nx,ny = xsize
  px,py = psize
  x = reshape(x,nx,ny)
  x_pad = repeat(x,2,2)[1:nx+px-1,1:ny+py-1] # pad image using periodic boundary conditions
  α = zeros(T,size(D,2),nx,ny)
  patch = zeros(T,px*py)
  for j=1:ny
    for i=1:nx
      patch[:] .= vec(x_pad[i:i+px-1,j:j+py-1])
      norm(patch)==0 &amp;&amp; continue
      # matchingpursuit is contained in Wavelets.jl
      α[:,i,j] .= matchingpursuit(patch, x-&gt;D*x, x-&gt;transpose(D)*x, tol)
    end
  end
  return vec(α)
end</code></pre><p>Synthetization can be done by</p><pre><code class="language-julia">function synthesizeImage(α::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64}) where T
  nx,ny = xsize
  px,py = psize
  x = zeros(T,nx+px-1,ny+py-1)
  α = reshape(α,:,nx,ny)
  for j=1:ny
    for i=1:nx
      x[i:i+px-1,j:j+py-1] .+= reshape(D*α[:,i,j],px,py)
    end
  end
  return vec(x[1:nx,1:ny])/(px*py)
end</code></pre><p>Once we have those two operations we can setup up a dictionary operator:</p><pre><code class="language-julia">function dictOp(D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64},tol::Float64=1.e-3) where T
  produ = x-&gt;analyzeImage(x,D,xsize,psize,tol=tol)
  ctprodu = x-&gt;synthesizeImage(x,D,xsize,psize)
  return LinearOperator(prod(xsize)*size(D,2),prod(xsize),false,false
          , produ
          , nothing
          , ctprodu )
end</code></pre><p>To test our method, let us load some simulated data and subsample it</p><pre><code class="language-julia"># phantom
img = readdlm(&quot;data/mribrain100.tsv&quot;)

acqData = AcquisitionData(ISMRMRDFile(&quot;data/acqDataBrainSim100.h5&quot;))
nx,ny = acqData.encodingSize

# undersample kspace data
acqData = sample_kspace(acqData, 2.0, &quot;poisson&quot;, calsize=25,profiles=false);</code></pre><p>Now we load a pre-trained dictionary, build the sparsifying transform and perform the reconstruction</p><pre><code class="language-julia"># load the dictionary
D = ComplexF64.(readdlm(&quot;data/brainDict98.tsv&quot;))

# some parameters
px, py = (6,6)  # patch size
K = px*py       # number of atoms

# CS reconstruction using Wavelets
params = Dict{Symbol,Any}()
params[:reco] = &quot;standard&quot;
params[:reconSize] = (nx,ny)
params[:iterations] = 50
params[:λ] = 2.e-2
params[:regularization] = &quot;L1&quot;
params[:sparseTrafo] = dictOp(D,(nx,ny),(px,py),2.e-2)
params[:ρ] = 0.1
params[:solver] = &quot;admm&quot;
params[:absTol] = 1.e-4
params[:relTol] = 1.e-2

img_d = reconstruction(acqData,params)</code></pre><p>For comparison, let us perform the same reconstruction as above but with a Wavelet transform</p><pre><code class="language-julia">delete!(params, :sparseTrafo)
params[:sparseTrafoName] = &quot;Wavelet&quot;

img_w = reconstruction(acqData,params)</code></pre><p>The following pictures shows the wavelet based CS reconstruction on the left and the dictionary based CS reconstruction on the right:</p><p><img src="assets/brainWavelet.png" alt="BrainWavelet"/> <img src="assets/brainDict.png" alt="BrainDict"/></p><p>For reference, the original data is shown here:</p><p><img src="assets/brainOrig.png" alt="BrainOrig"/></p><p>One can clearly see that the dictionary approach performs better than a simple Wavelet L1 prior.</p><footer><hr/><a class="previous" href="compressedSensing.html"><span class="direction">Previous</span><span class="title">Compressed Sensing</span></a><a class="next" href="API.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
