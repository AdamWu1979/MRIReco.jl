<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Julia MRI Package</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Julia MRI Package logo"/></a><div class="docs-package-name"><span class="docs-autofit">Julia MRI Package</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="gettingStarted.html">Getting Started</a></li><li><a class="tocitem" href="overview.html">Overview</a></li><li><a class="tocitem" href="acquisitionData.html">Acquisition Data</a></li><li><a class="tocitem" href="filehandling.html">File Handling</a></li><li><a class="tocitem" href="image.html">Images</a></li><li><a class="tocitem" href="trajectories.html">Trajectory</a></li><li><a class="tocitem" href="operators.html">Imaging Operators</a></li><li><a class="tocitem" href="offresonance.html">Offresonance</a></li><li><a class="tocitem" href="SENSE.html">Parallel Imaging</a></li><li><a class="tocitem" href="compressedSensing.html">Compressed Sensing</a></li><li><a class="tocitem" href="custom.html">Customize</a></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Operators-1"><span>Operators</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Trajectories-1"><span>Trajectories</span></a></li><li><a class="tocitem" href="#Sequences-1"><span>Sequences</span></a></li><li><a class="tocitem" href="#Sampling-1"><span>Sampling</span></a></li><li><a class="tocitem" href="#Simulation-1"><span>Simulation</span></a></li><li><a class="tocitem" href="#Reconstruction-1"><span>Reconstruction</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MagneticResonanceImaging/MRIReco.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><p>This page contains documentation of the public API of MRIReco. In the Julia REPL one can access this documentation by entering the help mode with <code>?</code> and then writing the function for which the documentation should be shown.</p><h2 id="Operators-1"><a class="docs-heading-anchor" href="#Operators-1">Operators</a><a class="docs-heading-anchor-permalink" href="#Operators-1" title="Permalink"></a></h2><p>Operators are implemented as subtypes of <code>AbstractLinearOperator</code>, which is defined in the package <code>LinearOperators.jl</code>. Such operators must provide a function implementing the product and a function implementing the product with the adjoint. Furthermore, the number of rows and columns of the operator must be specified.</p><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOps2d_simple" href="#MRIReco.encodingOps2d_simple"><code>MRIReco.encodingOps2d_simple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOps2d_simple(acqData::AcquisitionData, shape::NTuple{2,Int64}
                          ; slice=1
                          , correctionMap::Array{ComplexF64}=ComplexF64[]
                          , method::String=&quot;nfft&quot;)</code></pre><p>generates an Array of LinearOperators which describe 2d signal encoding of the individual contrasts in an MRI acquisition (for a given slice).</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>shape::NTuple{2,Int64}</code>              - size of image to be encoded/reconstructed</li><li><code>slice=1</code>                             - slice to be encoded/reconstructed</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOps3d_simple" href="#MRIReco.encodingOps3d_simple"><code>MRIReco.encodingOps3d_simple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOps3d_simple(acqData::AcquisitionData, shape::NTuple{2,Int64}
                          ; correctionMap::Array{ComplexF64}=ComplexF64[]
                          , method::String=&quot;nfft&quot;)</code></pre><p>generates an Array of LinearOperators which describe 3d signal encoding of the individual contrasts&amp;coils in an MRI acquisition (for a given slice). Arguments are the same as in the 2d case, with the exception that shape is of type <code>NTuple{3,Int64}</code> and the considered slice is not specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOps2d_parallel" href="#MRIReco.encodingOps2d_parallel"><code>MRIReco.encodingOps2d_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOps2d_parallel(acqData::AcquisitionData, shape::NTuple{2,Int64}
                          , senseMaps::Array{ComplexF64}
                          ; slice=1
                          , correctionMap::Array{ComplexF64}=ComplexF64[]
                          , method::String=&quot;nfft&quot;)</code></pre><p>generates an Array of LinearOperators which describe 2d signal encoding of the individual contrasts in an MRI acquisition (for a given slice). The different coils are taken into account in terms of their sensitivities</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>shape::NTuple{2,Int64}</code>              - size of image to be encoded/reconstructed</li><li><code>senseMaps::Array{ComplexF64}</code>        - coil sensitivities</li><li><code>slice=1</code>                             - slice to be encoded/reconstructed</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOps3d_parallel" href="#MRIReco.encodingOps3d_parallel"><code>MRIReco.encodingOps3d_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOps3d_parallel(acqData::AcquisitionData, shape::NTuple{2,Int64}
                          , senseMaps::Array{ComplexF64}
                          ; correctionMap::Array{ComplexF64}=ComplexF64[]
                          , method::String=&quot;nfft&quot;)</code></pre><p>generates an Array of LinearOperators which describe 3d signal encoding of the individual contrasts in an MRI acquisition (for a given slice). The different coils are taken into account in terms of their sensitivities Arguments are the same as in the 2d case, with the exception that shape is of type <code>NTuple{3,Int64}</code> and the considered slice is not specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOp2d_multiEcho" href="#MRIReco.encodingOp2d_multiEcho"><code>MRIReco.encodingOp2d_multiEcho</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOp2d_multiEcho(acqData::AcquisitionData, shape::NTuple{2,Int64}
                            ; slice::Int64=1
                            , correctionMap::Array{ComplexF64}=ComplexF64[]
                            , method::String=&quot;nfft&quot;)</code></pre><p>generates a LinearOperator which describe combined 2d signal encoding of all the contrasts in an MRI acquisition (for a given slice).</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>shape::NTuple{2,Int64}</code>              - size of image to be encoded/reconstructed</li><li><code>slice=1</code>                             - slice to be encoded/reconstructed</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOp3d_multiEcho" href="#MRIReco.encodingOp3d_multiEcho"><code>MRIReco.encodingOp3d_multiEcho</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOp3d_multiEcho(acqData::AcquisitionData, shape::NTuple{2,Int64}
                            ; correctionMap::Array{ComplexF64}=ComplexF64[])</code></pre><p>generates a LinearOperator which describe combined 3d signal encoding of all the contrasts in an MRI acquisition (for a given slice). Arguments are the same as in the 2d case, with the exception that shape is of type <code>NTuple{3,Int64}</code> and the considered slice is not specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOp2d_multiEcho_parallel" href="#MRIReco.encodingOp2d_multiEcho_parallel"><code>MRIReco.encodingOp2d_multiEcho_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOp2d_multiEcho_parallel(acqData::AcquisitionData, shape::NTuple{2,Int64}
                                      , senseMaps::Array{ComplexF64}
                                      ; slice=1
                                      , correctionMap::Array{ComplexF64}=ComplexF64[]
                                      , method::String=&quot;nfft&quot;)</code></pre><p>generates a LinearOperator which describe combined 3d signal encoding of all the contrasts in an MRI acquisition (for a given slice). The different coils are taken into account in terms of their sensitivities</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>shape::NTuple{2,Int64}</code>              - size of image to be encoded/reconstructed</li><li><code>senseMaps::Array{ComplexF64}</code>        - coil sensitivities</li><li><code>slice=1</code>                             - slice to be encoded/reconstructed</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.encodingOp3d_multiEcho_parallel" href="#MRIReco.encodingOp3d_multiEcho_parallel"><code>MRIReco.encodingOp3d_multiEcho_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encodingOp3d_multiEcho_parallel(acqData::AcquisitionData, shape::NTuple{2,Int64}
                                      , senseMaps::Array{ComplexF64}
                                      ; correctionMap::Array{ComplexF64}=ComplexF64[]
                                      , method::String=&quot;nfft&quot;)</code></pre><p>generates a LinearOperator which describe combined 3d signal encoding of all the contrasts in an MRI acquisition (for a given slice). The different coils are taken into account in terms of their sensitivities Arguments are the same as in the 2d case, with the exception that shape is of type <code>NTuple{3,Int64}</code> and the considered slice is not specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.fourierEncodingOp2d" href="#MRIReco.fourierEncodingOp2d"><code>MRIReco.fourierEncodingOp2d</code></a> — <span class="docstring-category">Function</span></header><section><div><p>return 2d Fourier encoding operator (either Explicit or NFFT)</p><ul><li><code>opname</code> : &quot;explicit&quot; or &quot;fast&quot;</li><li><code>slice</code> : slice to which the operator will be applied</li></ul><p>echoImage : calculate signal evolution relative to the echo time</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.fourierEncodingOp3d" href="#MRIReco.fourierEncodingOp3d"><code>MRIReco.fourierEncodingOp3d</code></a> — <span class="docstring-category">Function</span></header><section><div><p>return 3d Fourier encoding operator (either Explicit, FFT or NFFT)   opname : &quot;explicit&quot;, &quot;fft&quot; or &quot;fast&quot;   echoImage : calculate signal evolution relative to the echo time</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.ExplicitOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64,D}},Trajectory,Array{Complex{Float64},D}}} where D" href="#MRIReco.ExplicitOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64,D}},Trajectory,Array{Complex{Float64},D}}} where D"><code>MRIReco.ExplicitOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ExplicitOp(shape::NTuple{D,Int64}, tr::Trajectory, correctionmap::Array{ComplexF64,D}
        ; echoImage::Bool=false, kargs...) where D</code></pre><p>generates a <code>ExplicitOp</code> which explicitely evaluates the MRI Fourier signal encoding operator.</p><p><strong>Arguments:</strong></p><ul><li><code>shape::NTuple{D,Int64}</code>             - size of image to encode/reconstruct</li><li><code>tr::Trajectory</code>                     - Trajectory with the kspace nodes to sample</li><li><code>correctionmap::Array{ComplexF64,D}</code> - fieldmap for the correction of off-resonance effects</li><li><code>echoImage::Bool=false</code>              - if true sampling times will only be considered relative to the echo time                                        this results in complex valued image even for real-valued input.</li><li><code>kargs</code>                              - additional keyword arguments</li></ul></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>RegularizedLeastSquares.FFTOp(T::Type, shape::Tuple, shift=true)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MRIReco.NFFTOp-Tuple{Tuple,Trajectory}" href="#MRIReco.NFFTOp-Tuple{Tuple,Trajectory}"><code>MRIReco.NFFTOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NFFTOp(shape::Tuple, tr::Trajectory; nodes=nothing, kargs...)</code></pre><p>generates a <code>NFFTOp</code> which evaluates the MRI Fourier signal encoding operator using the NFFT.</p><p><strong>Arguments:</strong></p><ul><li><code>shape::NTuple{D,Int64}</code>  - size of image to encode/reconstruct</li><li><code>tr::Trajectory</code>          - Trajectory with the kspace nodes to sample</li><li>(<code>nodes=nothing</code>)         - Array containg the trajectory nodes (redundant)</li><li>(<code>kargs</code>)                   - additional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.FieldmapNFFTOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64,D}},Trajectory,Array{Complex{Float64},D}}} where D" href="#MRIReco.FieldmapNFFTOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64,D}},Trajectory,Array{Complex{Float64},D}}} where D"><code>MRIReco.FieldmapNFFTOp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FieldmapNFFTOp(shape::NTuple{D,Int64}, tr::Trajectory,
                    correctionmap::Array{ComplexF64,D};
                    method::String=&quot;nfft&quot;,
                    echoImage::Bool=true,
                    alpha::Float64=1.75,
                    m::Float64=3.0,
                    K=20,
                    kargs...) where D</code></pre><p>generates a <code>FieldmapNFFTOp</code> which evaluates the MRI Fourier signal encoding operator, including B0-inhomogeneities using time-segmented NFFTs.</p><p><strong>Arguments:</strong></p><ul><li><code>shape::NTuple{D,Int64}</code>             - size of image to encode/reconstruct</li><li><code>tr::Trajectory</code>                     - Trajectory with the kspace nodes to sample</li><li><code>correctionmap::Array{ComplexF64,D}</code> - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)            - method to use for time-segmentation when correctio field inhomogeneities</li><li>(<code>echoImage::Bool=false</code>)            - if true sampling times will only be considered relative to the echo time                                        this results in complex valued image even for real-valued input.</li><li>(<code>alpha::Float64=1.75</code>)              - oversampling factor for interpolation</li><li>(<code>m::Float64=3.0</code>)                   - truncation size of interpolation kernel</li><li>(<code>K=20</code>)                             - number of translates for LeastSquares approaches                                        (not NFFT-approach) to time-segmentation</li><li>(<code>kargs</code>)                            - additional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.SamplingOp" href="#MRIReco.SamplingOp"><code>MRIReco.SamplingOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SamplingOp(pattern::Array{Int}, shape::Tuple)</code></pre><p>buildsa <code>LinearOperator</code> which only returns the vector elements at positions indicated by pattern.</p><p><strong>Arguents</strong></p><ul><li><code>pattern::Array{Int}</code> - indices to sample</li><li><code>shape::Tuple</code>        - size of the array to sample</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.SensitivityOp" href="#MRIReco.SensitivityOp"><code>MRIReco.SensitivityOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SensitivityOp(sensMaps::Matrix{ComplexF64}, numEchoes::Int=1)</code></pre><p>builds a <code>LinearOperator</code> which performs multiplication of a given image with the coil sensitivities specified in <code>sensMaps</code></p><p><strong>Arguments</strong></p><ul><li><code>sensMaps::Matrix{ComplexF64}</code>  - sensitivity maps ( 1. dim -&gt; voxels, 2. dim-&gt; coils)</li><li><code>numEchoes</code>                     - number of contrasts to which the opetaor will be applied</li></ul></div></section><section><div><pre><code class="language-none">SensitivityOp(sensMaps::Array{T,4}, numEchoes::Int=1) where T</code></pre><p>builds a <code>LinearOperator</code> which performs multiplication of a given image with the coil sensitivities specified in <code>sensMaps</code></p><p><strong>Arguments</strong></p><ul><li><code>sensMaps::Array{T,4}</code>  - sensitivity maps ( 1.-3. dim -&gt; voxels, 4. dim-&gt; coils)</li><li><code>numEchoes</code>             - number of contrasts to which the opetaor will be applied</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.SparseOp" href="#MRIReco.SparseOp"><code>MRIReco.SparseOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SparseOp(name::AbstractString, shape::NTuple{N,Int64}; kargs...) where N</code></pre><p>generates the sparsifying transform (<code>&lt;: AbstractLinearOperator</code>) given its name.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>    - name of the sparsifying transform</li><li><code>shape::NTuple{N,Int64}</code>  - size of the Array to be transformed</li><li>(<code>kargs</code>)                 - additional keyword arguments</li></ul></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MRIReco.RegularizedLeastSquares.WeightingOp</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.AcquisitionData" href="#MRIReco.AcquisitionData"><code>MRIReco.AcquisitionData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct describing MRI acquisition data.</p><p><strong>Fields</strong></p><ul><li><code>sequenceInfo::Dict{Symbol,Any}</code>          - additional information on the pulse sequence</li><li><code>traj::Vector{Trajectory}</code>                - trajectories for each echo/contrast</li><li><code>kdata::Array{Matrix{ComplexF64},3}</code>      - each matrix contains data for one trajectory                                             (1. dim k-space nodes, 2. dim coils)                                             the outer dims describe:                                             1. dim echoes, 2. dim slices, 3. dim repetitions</li><li><code>subsampleIndices::Vector{Array{Int64}}</code>  - indices sampled for each echo/contrast</li><li><code>encodingSize::Vector{Int64}</code>             - size of the underlying image matrix</li><li><code>fov::Vector{Float64}</code>                    - field of view in m</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.AcquisitionData-Union{Tuple{T}, Tuple{T,Array{Array{Complex{Float64},2},3}}} where T&lt;:Union{Array{Trajectory,1}, Trajectory}" href="#MRIReco.AcquisitionData-Union{Tuple{T}, Tuple{T,Array{Array{Complex{Float64},2},3}}} where T&lt;:Union{Array{Trajectory,1}, Trajectory}"><code>MRIReco.AcquisitionData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AcquisitionData(tr::T,kdata::Array{Matrix{ComplexF64},3}; seqInfo=Dict{Symbol,Any}()
                    , idx=nothing, encodingSize=Int64[0,0,0], fov=Float64[0,0,0]
                    , kargs...) where T &lt;: Union{Trajectory,Vector{Trajectory}}</code></pre><p>constructor for <code>AcquisitionData</code></p><p><strong>Arguments</strong></p><ul><li><code>tr &lt;: Union{Trajectory,Vector{Trajectory}}</code> - trajectories</li><li><code>kdata::Array{Matrix{ComplexF64},3}</code>         - k-space data</li></ul><p>the other fields of <code>AcquisitionData</code> can be passed as keyword arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.trajectory" href="#MRIReco.trajectory"><code>MRIReco.trajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trajectory(acqData::AcquisitionData,i::Int64=1)</code></pre><p>returns the <code>i</code>-th trajectory contained in <code>acqData</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numContrasts-Tuple{AcquisitionData}" href="#MRIReco.numContrasts-Tuple{AcquisitionData}"><code>MRIReco.numContrasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numContrasts(acqData::AcquisitionData)</code></pre><p>returns the number of contrasts/echoes in acqData</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numChannels" href="#MRIReco.numChannels"><code>MRIReco.numChannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numChannels(acqData::AcquisitionData)</code></pre><p>returns the number of channels/coils in acqData</p></div></section><section><div><pre><code class="language-none">numChannels(f::RawAcquisitionData)</code></pre><p>returns the number of channels in a <code>RawAcquisitionData</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numSlices" href="#MRIReco.numSlices"><code>MRIReco.numSlices</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>numSlices(tr::Trajectory)</code> returns the number of slices of a trajectory </p></div></section><section><div><pre><code class="language-none">numSlices(acqData::AcquisitionData)</code></pre><p>returns the number of slices in acqData</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numRepititions" href="#MRIReco.numRepititions"><code>MRIReco.numRepititions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numRepititions(acqData::AcquisitionData)</code></pre><p>returns the number of repetitions in acqData</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.kData" href="#MRIReco.kData"><code>MRIReco.kData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kData(acqData::AcquisitionData, echo::Int64=1, coil::Int64=1, slice::Int64=1;rep::Int64=1)</code></pre><p>returns the k-space contained in <code>acqData</code> for given <code>echo</code>, <code>coil</code>, <code>slice</code> and <code>rep</code>(etition).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.multiEchoData" href="#MRIReco.multiEchoData"><code>MRIReco.multiEchoData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiEchoData(acqData::AcquisitionData, coil::Int64, slice::Int64;rep::Int64=1)</code></pre><p>returns the k-space contained in <code>acqData</code> for all echoes and given <code>coil</code>, <code>slice</code> and <code>rep</code>(etition).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.multiCoilData" href="#MRIReco.multiCoilData"><code>MRIReco.multiCoilData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiCoilData(acqData::AcquisitionData, echo::Int64, slice::Int64;rep::Int64=1)</code></pre><p>returns the k-space contained in <code>acqData</code> for all coils and given <code>echo</code>, <code>slice</code> and <code>rep</code>(etition).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.multiCoilMultiEchoData" href="#MRIReco.multiCoilMultiEchoData"><code>MRIReco.multiCoilMultiEchoData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiCoilMultiEchoData(acqData::AcquisitionData, echo::Int64, slice::Int64;rep::Int64=1)</code></pre><p>returns the k-space contained in <code>acqData</code> for all coils, echoes and given <code>slice</code> and <code>rep</code>(etition).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.profileData" href="#MRIReco.profileData"><code>MRIReco.profileData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">profileData(acqData::AcquisitionData, echo::Int64, slice::Int64, rep::Int, prof_tr::Int)</code></pre><p>returns the profile-data <code>prof_tr</code> contained in <code>acqData</code> for given <code>echo</code>, <code>coil</code>, <code>slice</code> and <code>rep</code>(etition).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.samplingDensity" href="#MRIReco.samplingDensity"><code>MRIReco.samplingDensity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samplingDensity(acqData::AcquisitionData,shape::Tuple)</code></pre><p>returns the sampling density for all trajectories contained in <code>acqData</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.changeEncodingSize2D" href="#MRIReco.changeEncodingSize2D"><code>MRIReco.changeEncodingSize2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">changeEncodingSize2D(acqData::AcquisitionData,newEncodingSize::Vector{Int64})</code></pre><p>changes the encoding size of 2d encoded <code>acqData</code> to <code>newEncodingSize</code>. Returns a new <code>AcquisitionData</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.convert3dTo2d" href="#MRIReco.convert3dTo2d"><code>MRIReco.convert3dTo2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert3dTo2d(acqData::AcquisitionData)</code></pre><p>convert the 3d encoded AcquisitionData <code>acqData</code> to the equivalent 2d AcquisitionData.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.RawAcquisitionData" href="#MRIReco.RawAcquisitionData"><code>MRIReco.RawAcquisitionData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>RawAcquisitionData object.</p><p><strong>Fields</strong></p><ul><li><code>params::Dict{String, Any}</code> - Dict containing the information of the XML header in ISMRMRD</li><li><code>profiles::Vector{Profile}</code> - Vector containing all the profiles of the acquisition</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.trajectory-Tuple{RawAcquisitionData}" href="#MRIReco.trajectory-Tuple{RawAcquisitionData}"><code>MRIReco.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><p>trajectory(f::RawAcquisitionData; slice::Int=1, contrast::Int=1)</p><p>returns the <code>Trajectory</code> for given <code>slice</code> and <code>contrast</code> of a <code>RawAcquisitionData</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.rawdata-Tuple{RawAcquisitionData}" href="#MRIReco.rawdata-Tuple{RawAcquisitionData}"><code>MRIReco.rawdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rawdata(f::RawAcquisitionData)</code></pre><p>returns the rawdata contained <code>RawAcquisitionData</code> object. The output is an <code>Array{Matrix{ComplexF64},3}</code>, which can be stored in a <code>AcquisitionData</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.AcquisitionData-Tuple{RawAcquisitionData}" href="#MRIReco.AcquisitionData-Tuple{RawAcquisitionData}"><code>MRIReco.AcquisitionData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AcquisitionData(f::RawAcquisitionData)</code></pre><p>converts <code>RawAcquisitionData</code> into the equivalent <code>AcquisitionData</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.RawAcquisitionData" href="#MRIReco.RawAcquisitionData"><code>MRIReco.RawAcquisitionData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawAcquisitionData(f::ISMRMRDFile, dataset=&quot;dataset&quot;)</code></pre><p>reads the <code>ISMRMRDFile</code> f and stores the result in a <code>RawAcquisitionDataObject</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.AcquisitionData" href="#MRIReco.AcquisitionData"><code>MRIReco.AcquisitionData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AcquisitionData(f::ISMRMRDFile, dataset=&quot;dataset&quot;)</code></pre><p>reads the <code>ISMRMRDFile</code> f and stores the result in an <code>AcquisitionDataObject</code></p></div></section></article><h2 id="Trajectories-1"><a class="docs-heading-anchor" href="#Trajectories-1">Trajectories</a><a class="docs-heading-anchor-permalink" href="#Trajectories-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.Trajectory" href="#MRIReco.Trajectory"><code>MRIReco.Trajectory</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct describing a trajectory</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>                  - name of the trajectory</li><li><code>nodes::Matrix{Float64}</code>        - sampling locations in k-space.                                   (1.dim &lt;-&gt; dimensions of k-space, 2. dim &lt;-&gt; sampling points)</li><li><code>times::Vector{Float64}</code>        - sampling times in s</li><li><code>TE::Float64</code>                   - echo time in s</li><li><code>AQ::Float64</code>`                  - readout duration in s (per profile)</li><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li><code>numSlices::Int64</code>              - number of slices (for 3d trajectories)</li><li><code>cartesian::Bool</code>               - true if sampling points lie on a cartesian grid</li><li><code>circular::Bool</code>                - true if kspace is covered in a circular domain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.trajectory-Tuple{AbstractString,Int64,Int64}" href="#MRIReco.trajectory-Tuple{AbstractString,Int64,Int64}"><code>MRIReco.trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trajectory(trajName::AbstractString, numProfiles::Int, numSamplingPerProfile::Int; numSlices::Int64=1, TE::Float64=0.0, AQ::Float64=1.e-3, kargs...)</code></pre><p>is a factory method to construct a trajectory from its <code>name</code></p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>                  - name of the trajectory</li><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>numSlices::Int64=1</code>)          - number of slices (for 3d trajectories)</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li><code>kargs...</code>                      - addional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{Trajectory}" href="#Base.string-Tuple{Trajectory}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>string(tr::Trajectory)</code> returns the name of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.echoTime-Tuple{Trajectory}" href="#MRIReco.echoTime-Tuple{Trajectory}"><code>MRIReco.echoTime</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>echoTime(tr::Trajectory)</code> returns the echo time of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.acqTimePerProfile-Tuple{Trajectory}" href="#MRIReco.acqTimePerProfile-Tuple{Trajectory}"><code>MRIReco.acqTimePerProfile</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>acqTimePerProfile(tr::Trajectory)</code> returns the acquisition time per profile of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numProfiles-Tuple{Trajectory}" href="#MRIReco.numProfiles-Tuple{Trajectory}"><code>MRIReco.numProfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>string(tr::Trajectory)</code> returns the name of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numSamplingPerProfile-Tuple{Trajectory}" href="#MRIReco.numSamplingPerProfile-Tuple{Trajectory}"><code>MRIReco.numSamplingPerProfile</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>numSamplingPerProfile(tr::Trajectory)</code> returns the number of samples per profile of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numSlices-Tuple{Trajectory}" href="#MRIReco.numSlices-Tuple{Trajectory}"><code>MRIReco.numSlices</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>numSlices(tr::Trajectory)</code> returns the number of slices of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.isCircular-Tuple{Trajectory}" href="#MRIReco.isCircular-Tuple{Trajectory}"><code>MRIReco.isCircular</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isCircular(tr::Trajectory)</code> returns whether the trajectory has circular k-space coverage </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.isCartesian-Tuple{Trajectory}" href="#MRIReco.isCartesian-Tuple{Trajectory}"><code>MRIReco.isCartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isCartesian(tr::Trajectory)</code> returns whether the trajectory nodes lie on a cartesian grid</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.dims-Tuple{Trajectory}" href="#MRIReco.dims-Tuple{Trajectory}"><code>MRIReco.dims</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>dims(tr::Trajectory)</code> returns the number of dimensions of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.kspaceNodes-Tuple{Trajectory}" href="#MRIReco.kspaceNodes-Tuple{Trajectory}"><code>MRIReco.kspaceNodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>kspaceNodes(tr::Trajectory)</code> returns the kspace sampling points of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.readoutTimes-Tuple{Trajectory}" href="#MRIReco.readoutTimes-Tuple{Trajectory}"><code>MRIReco.readoutTimes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>readoutTimes(tr::Trajectory)</code> returns the readoutTimes for the sampling points of a trajectory </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.CartesianTrajectory" href="#MRIReco.CartesianTrajectory"><code>MRIReco.CartesianTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CartesianTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , kmin=(-0.5,-0.5)
              , kmax=(0.5,0.5)
              , kargs...)</code></pre><p>returns a 2d cartesian trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>kmin=(-0.5,-0.5)</code>)            - minimum values of the covered k-space (for partial Fourier imaging)</li><li>(<code>kmax=(-0.5,-0.5)</code>)            - maximum values of the covered k-space (for partial Fourier imaging)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.EPITrajectory" href="#MRIReco.EPITrajectory"><code>MRIReco.EPITrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">EPITrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , EPI_factor::Int64=1
              , profileOffset= :equispaced
              , kargs...)</code></pre><p>returns a 2d cartesian trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>EPI_factor::Int64=1</code>)         - EPI factor, e.g. how many profiles to acquire per shot</li><li>(<code>profileOffset= :equispaced</code>)  - equispaced or random ordering of the shots</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.OneLine2dTrajectory" href="#MRIReco.OneLine2dTrajectory"><code>MRIReco.OneLine2dTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OneLine2dTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , angle::Float64=0.0
              , kargs...)</code></pre><p>returns a trajectory consisting of one arbitrarily rotated profile.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>angle::Float64=0.0</code>)          - angle of the profile (with respect to the x-axis) in radians</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.RadialTrajectory" href="#MRIReco.RadialTrajectory"><code>MRIReco.RadialTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RadialTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , angleOffset= :equispaced
              , kargs...)</code></pre><p>returns a 2d radial trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>angleOffset= :equispaced</code>)    - spacing of profile angles (<code>:equispaced</code> sampling, <code>:golden</code> angle sampling or <code>:random</code> sampling)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.SpiralTrajectory" href="#MRIReco.SpiralTrajectory"><code>MRIReco.SpiralTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SpiralTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , windings::Real= 6.25
              , angleOffset= :equispaced
              , kargs...)</code></pre><p>returns a 2d spiral trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>windings::Real= 6.25</code>)        - number of windings of the spiral profiles</li><li>(<code>angleOffset= :equispaced</code>)    - spacing of profile angles (<code>:equispaced</code> sampling, <code>:golden</code> angle sampling or <code>:random</code> sampling)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.SpiralTrajectoryVarDens" href="#MRIReco.SpiralTrajectoryVarDens"><code>MRIReco.SpiralTrajectoryVarDens</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SpiralTrajectoryVarDens(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , windings::Real= 6.25
              , alpha=2.0
              , angleOffset= :equispaced
              , kargs...)</code></pre><p>returns a 2d spiral trajectory with variable density</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>windings::Real= 6.25</code>)        - number of windings of the spiral profiles</li><li>(<code>alpha=2.0</code>)                   - exponent describing the evolution of the magnitude of the sampling points along the profiles</li><li>(<code>angleOffset= :equispaced</code>)    - spacing of profile angles (<code>:equispaced</code> sampling, <code>:golden</code> angle sampling or <code>:random</code> sampling)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.CartesianTrajectory3D" href="#MRIReco.CartesianTrajectory3D"><code>MRIReco.CartesianTrajectory3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">CartesianTrajectory3D(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , numSlices=1
              , kargs...)</code></pre><p>returns a 3d cartesian trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>numSlices=1</code>)                 - number of slices</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.KooshballTrajectory" href="#MRIReco.KooshballTrajectory"><code>MRIReco.KooshballTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">KooshballTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , kargs...)</code></pre><p>returns a 3d kooshball trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.StackOfStarsTrajectory" href="#MRIReco.StackOfStarsTrajectory"><code>MRIReco.StackOfStarsTrajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StackOfStarsTrajectory(numProfiles, numSamplingPerProfile
              ; TE::Float64=0.0
              , AQ::Float64=1.e-3
              , numSlices=1
              , angleOffset= :equispaced
              , kargs...)</code></pre><p>returns a 2d radial trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>numProfiles::Int64</code>            - number of profiles</li><li><code>numSamplingPerProfile::Int64</code>  - number of sampling points per profile</li><li>(<code>TE::Float64=0.0</code>)             - echo time in s</li><li>(<code>AQ::Float64=1.e-3</code>)           - readout duration in s (per profile)</li><li>(<code>numSlices=1</code>)                 - number of slices</li><li>(<code>angleOffset= :equispaced</code>)    - spacing of profile angles (<code>:equispaced</code> sampling, <code>:golden</code> angle sampling or <code>:random</code> sampling)</li></ul></div></section></article><h2 id="Sequences-1"><a class="docs-heading-anchor" href="#Sequences-1">Sequences</a><a class="docs-heading-anchor-permalink" href="#Sequences-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.MESequence" href="#MRIReco.MESequence"><code>MRIReco.MESequence</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>General Multi-Echo sequence with variable flip angles and TR.</strong></p><p>The phase of the excitation pulse has a phase of -90° in order to fulfill CPMG conditions.</p><p>For simplicity instantaneous pulses are assumed.</p><p>echoes apperat at times T<em>echo, 2*T</em>echo,..., numContrasts*T_echo after the excitation pulse</p><p><strong>Fields</strong></p><ul><li><code>excitationAngle::Float64</code>            - flip angle of the excitation pulse</li><li><code>refocusingAngles :: Vector{Float64}</code> - flip angles of the refocusing pulses</li><li><code>T_rf::Vector{Float64}</code>               - times of the refocusing pulses relative to the excitation pulse</li><li><code>T_echo:: Vector{Float64}</code>            - echo times relative to the excitation pulse</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.numContrasts-Tuple{MESequence}" href="#MRIReco.numContrasts-Tuple{MESequence}"><code>MRIReco.numContrasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numContrasts(seq::MESequence)</code></pre><p>returns the number of echoes of an <code>ME Sequence</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.echoTimes-Tuple{MESequence}" href="#MRIReco.echoTimes-Tuple{MESequence}"><code>MRIReco.echoTimes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">echoTimes(seq::MESequence)</code></pre><p>returns the echo times of an <code>ME Sequence</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.flipAngles-Tuple{MESequence}" href="#MRIReco.flipAngles-Tuple{MESequence}"><code>MRIReco.flipAngles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flipAngles(seq::MESequence)</code></pre><p>returns the refocusing flip angles of an <code>ME Sequence</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.echoAmplitudes" href="#MRIReco.echoAmplitudes"><code>MRIReco.echoAmplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">echoAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)</code></pre><p>calculates echo amplitudes for a given <code>MESequence</code> and given relaxation Rates R1, R2. Calculations are performed using the extended phase graph method. For simplicity instantaneous pulses are assumed. If <code>numStates=nothing</code> all dephasing states will be taken into account</p><p><strong>Arguments</strong></p><ul><li><code>seq::MESequence</code> - pulse sequence</li><li><code>R1::Float64</code> - R1 value to use (1/T1)</li><li><code>R2::Float64</code> - R2 value to use (1/T2)</li><li><code>numStates=nothing</code> - number of dephasing states to consider</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.epgAmplitudes" href="#MRIReco.epgAmplitudes"><code>MRIReco.epgAmplitudes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epgAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)</code></pre><p>calculates EPG amplitudes after each pulse of a given <code>MESequence</code> with the given relaxation Rates R1, R2. Calculations are performed using the extended phase graph method. For simplicity instantaneous pulses are assumed. If <code>numStates=nothing</code> all dephasing states will be taken into account</p><p><strong>Arguments</strong></p><ul><li><code>seq::MESequence</code> - pulse sequence</li><li><code>R1::Float64</code> - R1 value to use (1/T1)</li><li><code>R2::Float64</code> - R2 value to use (1/T2)</li><li><code>numStates=nothing</code> - number of dephasing states to consider</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.epgRotation" href="#MRIReco.epgRotation"><code>MRIReco.epgRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epgRotation(alpha::Float64, F::Vector{T}, Z::Vector{T}; statesConsidered=nothing, phi::Float64=0.0)</code></pre><p>applies Bloch-rotation (&lt;=&gt; RF pulse) to a set of EPG states.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Float64</code>           - flip angle of the RF pulse</li><li><code>F::Vector{T}</code>             - transverse dephasing stats</li><li><code>Z::Vector{T}</code>             - longitudinal dephasing stats</li><li><code>statesConsidered=nothing</code> - number of dephasing states to consider (nothing means all states are taken into account)</li><li><code>phi::Float64=0.0</code>         - phase of the RF pulse</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.epgRelaxation" href="#MRIReco.epgRelaxation"><code>MRIReco.epgRelaxation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epgRelaxation( R1::Float64, R2::Float64, t::Float64, F::Vector{T}, Z::Vector{T}) where T</code></pre><p>applies relaxation matrices to a set of EPG states.</p><p><strong>Arguments</strong></p><ul><li><code>R1::Float64</code>   - R1</li><li><code>R2::Float64</code>   - R2</li><li><code>t::Float64</code>    - length of time interval in s</li><li><code>F::Vector{T}</code>  - transverse dephasing stats</li><li><code>Z::Vector{T}</code>  - longitudinal dephasing stats</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.epgDephasing" href="#MRIReco.epgDephasing"><code>MRIReco.epgDephasing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epgDephasing(F::Vector{T}, n=1) where T = circshift(F[:],n)</code></pre><p>shifts the transverse dephasing states <code>F</code> corresponding to n dephasing-cycles.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.rfRotation" href="#MRIReco.rfRotation"><code>MRIReco.rfRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rfRotation(alpha, phi=0.)</code></pre><p>returns the rotation matrix for a pulse with flip angle <code>alpha</code> and phase <code>phi</code>.</p></div></section></article><h2 id="Sampling-1"><a class="docs-heading-anchor" href="#Sampling-1">Sampling</a><a class="docs-heading-anchor-permalink" href="#Sampling-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample" href="#MRIReco.sample"><code>MRIReco.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample(shape::NTuple{N,Int64}, redFac::Float64, patFunc::String; kargs...)</code></pre><p>generates a <code>Vector{Int64}</code> of indices to sample an Array of of size <code>shape</code> with a reduction factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{N,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li><code>patFunc::String</code>        - name of the sampling function                           (&quot;random, &quot;regular&quot;, &quot;lines&quot;, &quot;poisson&quot; or &quot;vdPoisson&quot;)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_kspace-Tuple{AbstractArray,Float64,AbstractString}" href="#MRIReco.sample_kspace-Tuple{AbstractArray,Float64,AbstractString}"><code>MRIReco.sample_kspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_kspace(data::AbstractArray, redFac::Float64, patFunc::String; kargs...)</code></pre><p>subsamples the Array <code>data</code> with a reduction factor <code>redFac</code> and returns both the subsampled Array (as a vector) and the sampled indices (as a vector)</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code>    - array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li><code>patFunc::String</code>        - name of the sampling function                           (&quot;random, &quot;regular&quot;, &quot;lines&quot;, &quot;poisson&quot; or &quot;vdPoisson&quot;)</li><li><code>kargs...</code>               - addional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_kspace-Tuple{AcquisitionData,Float64,AbstractString}" href="#MRIReco.sample_kspace-Tuple{AcquisitionData,Float64,AbstractString}"><code>MRIReco.sample_kspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_kspace(acqData::AcquisitionData,redFac::Float64,
            patFunc::AbstractString; rand=true, profiles=true,
            seed = 1234, kargs...)</code></pre><p>subsamples the data in <code>acqData</code> with reduction factor <code>redFac</code> and returns a new <code>AcquisitionData</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionDatay</code> - AcquisitionData to be sampled</li><li><code>redFac::Float64</code>           - subsampling factor</li><li><code>patFunc::String</code>           - name of the sampling function                               (&quot;random, &quot;regular&quot;, &quot;lines&quot;, &quot;poisson&quot; or &quot;vdPoisson&quot;)</li><li>(<code>rand=true</code>)               - use different patterns for the different contrasts</li><li>(<code>profiles=true</code>)           - sample complete profiles</li><li>(<code>seed=1234</code>)               - seed for the random number generator</li><li><code>kargs...</code>                  - addional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_regular-Tuple{Tuple,Float64}" href="#MRIReco.sample_regular-Tuple{Tuple,Float64}"><code>MRIReco.sample_regular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_regular(shape::Tuple{Int64,Int64},redFac::Float64;kargs...)</code></pre><p>generates a regular sampling pattern for an Array of size <code>shape</code> with a subsampling factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{N,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_random-Tuple{Tuple{Int64,Int64},Float64}" href="#MRIReco.sample_random-Tuple{Tuple{Int64,Int64},Float64}"><code>MRIReco.sample_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_random(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0,kargs...)</code></pre><p>generates a random sampling pattern for an Array of size <code>shape</code> with a subsampling factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{N,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li>(<code>calsize::Int64=0</code>)     - size of the fully sampled calibration area</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_poissondisk-Tuple{Tuple{Int64,Int64},Float64}" href="#MRIReco.sample_poissondisk-Tuple{Tuple{Int64,Int64},Float64}"><code>MRIReco.sample_poissondisk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_poissondisk(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0, seed::Int64=1234,kargs...)</code></pre><p>generates a Poisson disk sampling pattern for an Array of size <code>shape</code> with a subsampling factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{2,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li>(<code>calsize::Int64=0</code>)     - size of the fully sampled calibration area</li><li>(<code>seed=1234</code>)            - seed for the random number generator</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_vdpoisson-Tuple{Tuple{Int64,Int64},Float64}" href="#MRIReco.sample_vdpoisson-Tuple{Tuple{Int64,Int64},Float64}"><code>MRIReco.sample_vdpoisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_vdpoisson(shape::Tuple{Int64,Int64},redFac::Float64; seed::Int64=1234,kargs...)</code></pre><p>generates a variable density Poisson disk sampling pattern for an Array of size <code>shape</code> with a subsampling factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{2,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li>(<code>seed=1234</code>)            - seed for the random number generator</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.sample_lines-Tuple{Tuple{Int64,Int64},Float64}" href="#MRIReco.sample_lines-Tuple{Tuple{Int64,Int64},Float64}"><code>MRIReco.sample_lines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_lines(shape::Tuple{Int64,Int64},redFac::Float64;sampleFunc=&quot;random&quot;,kargs...)</code></pre><p>generates a pattern to sample complete lines of an Array of size <code>shape</code> with a subsampling factor <code>redFac</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::NTuple{N,Int64}</code> - size of the Array to be sampled</li><li><code>redFac::Float64</code>        - subsampling factor</li><li><code>sampleFunc=&quot;random&quot;</code>        - name of the sampling function                           (&quot;random, &quot;regular&quot;, &quot;lines&quot;, &quot;poisson&quot; or &quot;vdPoisson&quot;)</li><li><code>kargs...</code>               - addional keyword arguments</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.calculateIncoherence" href="#MRIReco.calculateIncoherence"><code>MRIReco.calculateIncoherence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calculateIncoherence(acqData::AcquisitionData, recoParams::Dict, slice=1)</code></pre><p>calculates the incoherence of the sampling pattern contained in <code>acqData</code></p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>  - AcquisitionData containing the sampling pattern</li><li><code>recoParams::Dict</code>          - Dict containing reconstruction parameters</li><li>(<code>slice=1</code>)                 - slice for which to calculate the incoherence</li></ul></div></section></article><h2 id="Simulation-1"><a class="docs-heading-anchor" href="#Simulation-1">Simulation</a><a class="docs-heading-anchor-permalink" href="#Simulation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,3},Dict}} where T&lt;:Union{Complex{Float64}, Float64}" href="#MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,3},Dict}} where T&lt;:Union{Complex{Float64}, Float64}"><code>MRIReco.simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulation(image::Array{T,3}, simParams::Dict) where T&lt;:Union{ComplexF64,Float64}</code></pre><p>Simulate MRI raw data from given <code>image</code> data. All simulation parameters are passed to the function in the form of a dictionary.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,3},Dict,String}} where T&lt;:Union{Complex{Float64}, Float64}" href="#MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,3},Dict,String}} where T&lt;:Union{Complex{Float64}, Float64}"><code>MRIReco.simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulation(image::Array{T,3}, simParams::Dict, filename::String) where T&lt;:Union{ComplexF64,Float64}</code></pre><p>Performs the same simulation as <code>simulation(image, simParams)</code> and saves the result in a file with name <code>filename</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,2},Dict}} where T&lt;:Union{Complex{Float64}, Float64}" href="#MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T,2},Dict}} where T&lt;:Union{Complex{Float64}, Float64}"><code>MRIReco.simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulation(image::Array{T,2}, simParams::Dict) where T&lt;:Union{ComplexF64,Float64}</code></pre><p>Simulate MRI raw data from given <code>image</code> data. All simulation parameters are passed to the function in the form of a dictionary.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.simulation" href="#MRIReco.simulation"><code>MRIReco.simulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simulation(tr::Trajectory, image::Array{ComplexF64}, correctionMap = []; opName=&quot;fast&quot;
          , senseMaps=[], verbose=true, kargs...)</code></pre><p>Transforms a given image to k-space Domain. Dispatches whether the trajectory is 2d or 3d The Fourier integrals can be evaluated exactly or using NFFT Returns the demodulated signal.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>tr::Trajectory</code>             - three-dimensional Trajectory</li><li><code>image::Array{ComplexF64,3}</code> - image to be transformed</li><li>(<code>correctionMap=[]</code>)         - sum of the field offresonance (imaginary) map and relaxation map (real)</li><li>(`opName=&quot;fast&quot;)             - name of operator to use (&quot;explicit&quot; or &quot;fast&quot;)</li><li>(<code>sensmaps=[]</code>)              - array of coil sensitivities</li><li>(<code>verbose=true</code>)             - prints the progress if true</li><li><code>kargs...</code>                   - addional keyword arguments</li></ul><p>...</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.simulation-Tuple{AbstractSequence,Array{Trajectory,1},Array{Complex{Float64},3}}" href="#MRIReco.simulation-Tuple{AbstractSequence,Array{Trajectory,1},Array{Complex{Float64},3}}"><code>MRIReco.simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulation(seq::AbstractSequence, tr::Vector{Trajectory}, image::Array{ComplexF64,3}
                ; opName=&quot;fast&quot;, r1map=[], r2map=[], fmap=[], senseMaps=[]
                , verbose=true, kargs...)</code></pre><p>Simulate k-space data for all echoes of a pulse sequence. The echo intensities are simulated using the EPG formalism The Fourier integrals can be evaluated exactly or using NFFT</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>seq::AbstractSequence</code>      - pulse sequence</li><li><code>tr::Vector{Trajectory}</code>     - trajectories for all contrasts</li><li><code>image::Array{ComplexF64,3}</code> - image to be transformed</li><li>(<code>r1map=[]</code>)                 - R1 map of the object (real)</li><li>(<code>r2map=[]</code>)                 - R2 map of the object (real) / (R2* for GRE sequences)</li><li>(<code>fmap=[]</code>)                  - fieldmap (real)</li><li>(`opName=&quot;fast&quot;)             - name of operator to use (&quot;explicit&quot; or &quot;fast&quot;)</li><li>(<code>sensmaps=[]</code>)              - array of coil sensitivities</li><li>(<code>verbose=true</code>)             - prints the progress if true</li><li><code>kargs...</code>                   - addional keyword arguments</li></ul><p>...</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.addNoise" href="#MRIReco.addNoise"><code>MRIReco.addNoise</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Adds average white gaussian noise to the signal x</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector</code>     - signal vector</li><li>&#39;snr::Float64&#39;  - target SNR</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.addNoise-Tuple{AcquisitionData,Float64}" href="#MRIReco.addNoise-Tuple{AcquisitionData,Float64}"><code>MRIReco.addNoise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>return AcquisitionData with white gaussian noise</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>  - AcquisitionData</li><li>&#39;snr::Float64&#39;              - target SNR</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.addNoise!-Tuple{AcquisitionData,Float64}" href="#MRIReco.addNoise!-Tuple{AcquisitionData,Float64}"><code>MRIReco.addNoise!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>add white gaussian noise to AcquisitionData with (in-place)</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>  - AcquisitionData</li><li>&#39;snr::Float64&#39;              - target SNR</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.birdcageSensitivity" href="#MRIReco.birdcageSensitivity"><code>MRIReco.birdcageSensitivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">birdcageSensitivity(N::Int64, ncoils::Int64, relative_radius::Float64)</code></pre><p>Computes the sensitivity maps for each coils that are arranged in a birdcage manner.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.quadraticFieldmap" href="#MRIReco.quadraticFieldmap"><code>MRIReco.quadraticFieldmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadraticFieldmap(Nx::Int64, Ny::Int64, maxOffresonance::Float64=125.0)</code></pre><p>Computes a parabolic fieldmap.</p></div></section></article><h2 id="Reconstruction-1"><a class="docs-heading-anchor" href="#Reconstruction-1">Reconstruction</a><a class="docs-heading-anchor-permalink" href="#Reconstruction-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction-Tuple{AcquisitionData,Dict}" href="#MRIReco.reconstruction-Tuple{AcquisitionData,Dict}"><code>MRIReco.reconstruction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reconstruction(acqData::AcquisitionData, recoParams::Dict)</code></pre><p>takes an AcquisitionData object and a parameter dictionary and calculates an image from the given raw data.</p><p>Reconstruction types are specified by the symbol <code>:reco</code>. Valid reconstruction names are:</p><ul><li>:direct - direct Fourier reconstruction</li><li>:standard           - iterative reconstruction for all contrasts, coils &amp; slices independently</li><li>:multiEcho          - iterative joint reconstruction of all echo images</li><li>:multiCoil          - SENSE-type iterative reconstruction</li><li>:multiCoilMultiEcho - SENSE-type iterative reconstruction of all echo images</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction-Tuple{AcquisitionData,Dict,String}" href="#MRIReco.reconstruction-Tuple{AcquisitionData,Dict,String}"><code>MRIReco.reconstruction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reconstruction(acqData::AcquisitionData, recoParams::Dict,filename::String; force=false)</code></pre><p>performs the same image reconstrucion as <code>reconstruction(acqData::AcquisitionData, recoParams::Dict)</code> and saves the image in a file with name <code>filename</code>. If <code>force=false</code>, the reconstructed image is loaded from the the file <code>filename</code> if the latter is present.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.setupIterativeReco" href="#MRIReco.setupIterativeReco"><code>MRIReco.setupIterativeReco</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setupIterativeReco(acqData::AcquisitionData, recoParams::Dict)</code></pre><p>builds relevant parameters and operators from the entries in <code>recoParams</code></p><p><strong>relevant parameters</strong></p><ul><li><code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct</li><li><code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData</li><li><code>sparseTrafo::AbstractLinearOperator</code> - sparsifying transformation</li><li><code>reg::Regularization</code>                 - Regularization to be used</li><li><code>normalize::Bool</code>                     - adjust regularization parameter according to the size of k-space data</li><li><code>solvername::String</code>                  - name of the solver to use</li><li><code>senseMaps::Array{ComplexF64}</code>        - coil sensitivities</li><li><code>correctionMap::Array{ComplexF64}</code>    - fieldmap for the correction of off-resonance effects</li><li><code>method::String=&quot;nfft&quot;</code>               - method to use for time-segmentation when correctio field inhomogeneities</li></ul><p><code>sparseTrafo</code> and <code>reg</code> can also be speficied using their names in form of a string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_direct_2d" href="#MRIReco.reconstruction_direct_2d"><code>MRIReco.reconstruction_direct_2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reconstruction_direct_2d(acqData::AcquisitionData, reconSize::NTuple{2,Int64}, weights::Vector{Vector{ComplexF64}}, correctionMap::Array{ComplexF64}=ComplexF64[])</code></pre><p>Performs a direct Fourier-based image reconstruction of 2d encoded AcquisitionData</p><p>input:   <code>acqData::AcquisitionData</code>            - AcquisitionData object   <code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct   <code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData   (<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_direct_3d" href="#MRIReco.reconstruction_direct_3d"><code>MRIReco.reconstruction_direct_3d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reconstruction_direct_3d(acqData::AcquisitionData, reconSize::NTuple{3,Int64}, weights::Vector{Vector{ComplexF64}}, correctionMap::Array{ComplexF64}=ComplexF64[])</code></pre><p>Performs a direct Fourier-based image reconstruction of 3d encoded AcquisitionData</p><p>input:   <code>acqData::AcquisitionData</code>            - AcquisitionData object   <code>reconSize::NTuple{3,Int64}</code>              - size of image to reconstruct   <code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData   <code>(correctionMap::Array{ComplexF64})</code>  - fieldmap for the correction of off-resonance effects</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_simple" href="#MRIReco.reconstruction_simple"><code>MRIReco.reconstruction_simple</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Performs iterative image reconstruction independently for the data of all coils, contrasts and slices</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct</li><li><code>reg::Regularization</code>                 - Regularization to be used</li><li><code>sparseTrafo::AbstractLinearOperator</code> - sparsifying transformation</li><li><code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData</li><li><code>solvername::String</code>                  - name of the solver to use</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li><li>(<code>normalize::Bool=false</code>)             - adjust regularization parameter according to the size of k-space data</li><li>(<code>params::Dict{Symbol,Any}</code>)          - Dict with additional parameters</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_multiEcho" href="#MRIReco.reconstruction_multiEcho"><code>MRIReco.reconstruction_multiEcho</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Performs a iterative image reconstruction jointly for all contrasts. Different slices and coil images are reconstructed independently.</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct</li><li><code>reg::Regularization</code>                 - Regularization to be used</li><li><code>sparseTrafo::AbstractLinearOperator</code> - sparsifying transformation</li><li><code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData</li><li><code>solvername::String</code>                  - name of the solver to use</li><li>(<code>correctionMap::Array{ComplexF64})</code>  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li><li>(<code>normalize::Bool=false</code>)             - adjust regularization parameter according to the size of k-space data</li><li>(<code>params::Dict{Symbol,Any}</code>)          - Dict with additional parameters</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_multiCoil" href="#MRIReco.reconstruction_multiCoil"><code>MRIReco.reconstruction_multiCoil</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Performs a SENSE-type iterative image reconstruction. Different slices and contrasts images are reconstructed independently.</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct</li><li><code>reg::Regularization</code>                 - Regularization to be used</li><li><code>sparseTrafo::AbstractLinearOperator</code> - sparsifying transformation</li><li><code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData</li><li><code>solvername::String</code>                  - name of the solver to use</li><li><code>senseMaps::Array{ComplexF64}</code>        - coil sensitivities</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li><li>(<code>normalize::Bool=false</code>)             - adjust regularization parameter according to the size of k-space data</li><li>(<code>params::Dict{Symbol,Any}</code>)          - Dict with additional parameters</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.reconstruction_multiCoilMultiEcho" href="#MRIReco.reconstruction_multiCoilMultiEcho"><code>MRIReco.reconstruction_multiCoilMultiEcho</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Performs a SENSE-type iterative image reconstruction which reconstructs all contrasts jointly. Different slices are reconstructed independently.</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>            - AcquisitionData object</li><li><code>reconSize::NTuple{2,Int64}</code>              - size of image to reconstruct</li><li><code>reg::Regularization</code>                 - Regularization to be used</li><li><code>sparseTrafo::AbstractLinearOperator</code> - sparsifying transformation</li><li><code>weights::Vector{Vector{ComplexF64}}</code> - sampling density of the trajectories in acqData</li><li><code>solvername::String</code>                  - name of the solver to use</li><li><code>senseMaps::Array{ComplexF64}</code>        - coil sensitivities</li><li>(<code>correctionMap::Array{ComplexF64}</code>)  - fieldmap for the correction of off-resonance effects</li><li>(<code>method::String=&quot;nfft&quot;</code>)             - method to use for time-segmentation when correctio field inhomogeneities</li><li>(<code>normalize::Bool=false</code>)             - adjust regularization parameter according to the size of k-space data</li><li>(<code>params::Dict{Symbol,Any}</code>)          - Dict with additional parameters</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.espirit" href="#MRIReco.espirit"><code>MRIReco.espirit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`maps = espirit(acqData::AcquisitionData, ksize::NTuple{2,Int64}, ncalib::Int64
           ; eigThresh_1::Float64=0.02, eigThresh_2::Float64=0.95)`</code></pre><p>obtains coil sensitivities from a calibration area using ESPIRiT adapted from the MATLAB code by Uecker et al. for the paper&#39; M. Uecker, P. Lai, MJ Murphy, P. Virtue, M Elad, JM Pauly, SS Vasanawala and M Lustig, &quot;ESPIRiT- an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA&quot;, Magn Reson Med, 2013</p><p>the matlab code can be found at: [http://people.eecs.berkeley.edu/~mlustig/Software.html]</p><p><strong>Arguments</strong></p><ul><li><code>acqData::AcquisitionData</code>  - AcquisitionData</li><li><code>ksize::NTuple{2,Int64}</code>    - size of the k-space matrix</li><li><code>ncalib::Int64</code>             - number of calibration points in each dimension</li><li><code>eigThresh_1::Float64=0.02</code> - threshold for the singular values of the calibration matrix (relative to the largest value)</li><li><code>eigThresh_2::Float64=0.95</code> - threshold of the image space kernels (if no singular value &gt; <code>eigThresh_2</code> exists)                               , the corresponding pixel has a sensitivity of 0.</li></ul><p>Returns a 4D array.</p></div></section><section><div><p><code>maps = espirit(calibData::Array{ComplexF64,3}, imsize::NTuple{2,Int64}, ksize::NTuple{2,Int64}                 ; eigThresh_1::Float64=0.02, eigThresh_2::Float64=0.95)</code> Returns a 3D array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIReco.nrmsd" href="#MRIReco.nrmsd"><code>MRIReco.nrmsd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrmsd(I,Ireco)</code></pre><p>computes the normalized root mean squared error of the image <code>Ireco</code> with respect to the image <code>I</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="custom.html">« Customize</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 15 December 2019 21:09">Sunday 15 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
